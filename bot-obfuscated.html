<script>
    // ============================================================================
    // CORE BOT FUNCTIONS
    // ============================================================================

    // Global State
    window.ws = null;
    window.req_id = 0;
    window.isBotRunning = false;
    window.isConnecting = false;
    window.soundEnabled = true;
    window.ToneInitialized = false;
    window.synth = null;

    // Trading State
    window.baseStake = 1.0;
    window.currentStake = 1.0;
    window.multiplier = 1.15;
    window.maxTrades = 10;
    window.tradeCount = 0;
    window.martingaleStep = 0;
    window.accountBalance = 0.0;
    window.startingBalance = 0.0;
    window.currentBalance = 0.0;
    window.netProfit = 0.0;

    // PnL Tracking
    window.pnlTracker = {
        totalInvestment: 0.0,
        totalPayout: 0.0,
        netProfit: 0.0,
        trades: []
    };

    // PnL Update Timer
    window.pnlUpdateInterval = null;
    window.pnlUpdateDuration = 3000; // 3 seconds

    // Execution State
    window.lastTick = null;
    window.nextTradeAllowed = true;
    window.stopAfterWin = false;
    window.pendingProposals = new Map();
    window.executionLock = false;

    // Statistics
    window.stats = {
        totalTicks: 0,
        tradesExecuted: 0,
        wins: 0,
        losses: 0
    };

    // Rate tracking
    window.botTickTimestamps = [];

    // Queue - INCREASED SIZE FOR BETTER REANALYSIS
    window.tickQueue = [];
    window.maxQueueSize = 30;

    // Analysis Engine
    let analysisDigits = [];
    let analysisWindowSize = 10;
    let analysisComplete = false;
    let suggestedDigit = null;
    let totalTicksReceived = 0;
    let lastTickTime = 0;
    let tickTimestamps = [];

    // Session State
    let sessionState = {
        active: false,
        mode: 'instant',
        sessionDigit: null,
        sessionStarted: false,
        manualOverride: false
    };

    // ADAPTIVE RECHECK SYSTEM - MODIFIED FOR QUEUE INTEGRATION
    window.recheckThreshold = 5;
    window.consecutiveLosses = 0;
    window.lastAnalysisTime = 0;
    window.recheckEnabled = false; // Disabled in favor of queue system
    window.digitChangesThisSession = 0;
    window.maxDigitChanges = 3;
    window.lastRecheckTime = 0;
    window.recheckCooldown = 10000;

    // Constants for Integration
    window.SMART_QUEUE_SIZE = 5;

    // Queue state
    window.digitQueue = {
        digits: [],            // Array of digits to cycle through
        position: 0,           // Current position in queue
        mode: 'sequential',    // 'sequential' or 'random'
        active: false,         // Whether queue is active
        currentDigit: null,    // Current digit being used
        cyclesCompleted: 0,    // Number of cycles completed
        maxCycles: 1,          // Maximum cycles before stopping
        cycleOnWin: true,      // Move to next digit on win
        restartAtEnd: true,    // Restart from beginning when queue ends
        queueExpanded: true,   // UI state
        shuffledDigits: [],    // For random mode
        shufflePosition: 0     // For random mode
    };

    // DOM Elements
    const toggleButton = document.getElementById('toggleButton');
    const soundToggleButton = document.getElementById('soundToggle');
    const sessionDisplay = document.getElementById('session_display');
    const tradeResultContainer = document.getElementById('trade-result-container');
    const metricPreviousResult = document.getElementById('metricPreviousResult');
    const metricNextAction = document.getElementById('metricNextAction');
    const metricTradeResult = document.getElementById('metricTradeResult');
    const metricTotalProfit = document.getElementById('metricTotalProfit');

    // ============================================================================
    // INTEGRATION 1: Automated Queue Population from Analysis
    // ============================================================================

    /**
     * INTEGRATION 1: Automated Queue Population from Analysis
     * Overwrites the standard analysis handler to feed the Digit Queue.
     */
    function processAnalysisResults() {
        if (analysisDigits.length < analysisWindowSize) return;
        
        // Calculate digit frequencies
        const digitFrequencies = Array(10).fill(0);
        analysisDigits.forEach(d => {
            if (d >= 0 && d <= 9) digitFrequencies[d]++;
        });
        
        // Sort digits by occurrence frequency (descending)
        const sortedDigits = Object.entries(digitFrequencies)
            .map((digit, index) => ({ digit: index, count: digit }))
            .sort((a, b) => b.count - a.count)
            .map(entry => entry.digit);
            
        // Extract the Top 5 digits
        const top5 = sortedDigits.slice(0, window.SMART_QUEUE_SIZE);
        
        log(`üß† Analysis Complete. Loading Top ${top5.length} into Queue: ${top5.join(', ')}`, 'ANALYSIS');
        
        // Populate the Global Digit Queue
        window.digitQueue.digits = top5;
        window.digitQueue.position = 0;
        window.digitQueue.active = true;
        
        // Refresh the UI to reflect the new queue
        updateDigitQueueDisplay();
        
        // Set the first digit from the new queue as the target
        const initialDigit = window.digitQueue.digits[0];
        document.getElementById('predictedDigit').value = initialDigit;
        window.digitQueue.currentDigit = initialDigit;
        
        // Update session digit in smart mode
        if (sessionState.mode === 'smart' && !sessionState.manualOverride) {
            sessionState.sessionDigit = initialDigit;
            sessionState.sessionStarted = true;
            sessionState.manualOverride = false;
        }
        
        log(`üéØ Queue Active. Starting with Prediction: ${initialDigit}`, 'QUEUE');
        
        // Update all UI elements
        updateQueueStatus();
        updateSessionDisplay();
        updatePredictionBox();
    }

    // Override the original performAnalysis function
    const originalPerformAnalysis = window.performAnalysis;
    window.performAnalysis = function() {
        if (analysisDigits.length < analysisWindowSize) return;
        
        if (sessionState.sessionStarted && sessionState.sessionDigit !== null) {
            log(`üîí Session active - digit ${sessionState.sessionDigit} remains locked`, 'SESSION');
            return;
        }
        
        try {
            processAnalysisResults();
            analysisComplete = true;
            window.lastAnalysisTime = Date.now();
            updatePredictionBox();
            updateExecutionLogic();
            
        } catch (error) {
            console.error('Analysis error:', error);
        }
    };

    // ============================================================================
    // INTEGRATION 2: Loss-Driven Queue Rotation
    // ============================================================================

    /**
     * INTEGRATION 2: Loss-Driven Queue Rotation
     * Modified handler to skip to the next digit in the analysis queue after a loss.
     */
    function handleContractResult(isWin) {
        if (isWin) {
            log("üí∞ WIN! Resetting stake to base.", "TRADE");
            window.currentStake = window.baseStake;
            window.martingaleStep = 0;
            window.consecutiveLosses = 0;
            
            // Optional: Move to next digit on win if the checkbox is checked
            if (window.digitQueue.cycleOnWin && window.digitQueue.digits.length > 1) {
                rotateQueue();
            } else {
                // Bot stops after win by default
                window.stopAfterWin = true;
            }
        } else {
            window.consecutiveLosses++;
            log(`‚ùå LOSS (${window.consecutiveLosses}). Rotating to next predicted digit.`, "TRADE");
            
            // Apply Martingale Multiplier
            window.currentStake = window.currentStake * window.multiplier;
            
            // Execute the rotation to the next digit in the analysis queue
            rotateQueue();
        }
        
        updateMetricsUI();
    }

    /**
     * Rotates the active digit based on current mode (Sequential or Random)
     */
    function rotateQueue() {
        if (window.digitQueue.digits.length === 0) {
            log("‚ö†Ô∏è Queue is empty. Re-run analysis or add digits.", "QUEUE");
            return;
        }

        if (window.digitQueue.mode === 'random') {
            // For random mode, shuffle if needed
            if (!window.digitQueue.shuffledDigits || window.digitQueue.shuffledDigits.length === 0) {
                window.digitQueue.shuffledDigits = [...window.digitQueue.digits];
                shuffleArray(window.digitQueue.shuffledDigits);
                window.digitQueue.shufflePosition = 0;
            }
            
            window.digitQueue.shufflePosition++;
            
            // Check if we completed a cycle
            if (window.digitQueue.shufflePosition >= window.digitQueue.shuffledDigits.length) {
                window.digitQueue.shuffledDigits = [];
                window.digitQueue.cyclesCompleted++;
                window.digitQueue.shufflePosition = 0;
            }
            
            const nextDigit = window.digitQueue.shuffledDigits[window.digitQueue.shufflePosition] || 
                             window.digitQueue.digits[0];
            window.digitQueue.currentDigit = nextDigit;
            
        } else {
            // Sequential rotation
            window.digitQueue.position = (window.digitQueue.position + 1) % window.digitQueue.digits.length;
            const nextDigit = window.digitQueue.digits[window.digitQueue.position];
            window.digitQueue.currentDigit = nextDigit;
        }

        document.getElementById('predictedDigit').value = window.digitQueue.currentDigit;
        
        // Update session digit
        if (sessionState.mode === 'smart') {
            sessionState.sessionDigit = window.digitQueue.currentDigit;
        }
        
        log(`‚è≠Ô∏è Queue Rotation: Next Digit is ${window.digitQueue.currentDigit}`, 'QUEUE');
        updateDigitQueueDisplay();
        updateQueueStatus();
        updateSessionDisplay();
    }

    // ============================================================================
    // DIGIT QUEUE SYSTEM FUNCTIONS
    // ============================================================================
    
    // Toggle queue panel visibility
    function toggleQueuePanel() {
        window.digitQueue.queueExpanded = !window.digitQueue.queueExpanded;
        const queueContent = document.getElementById('queuePanelContent');
        const toggleIcon = document.getElementById('queueToggleIcon');
        
        if (window.digitQueue.queueExpanded) {
            queueContent.classList.remove('hidden');
            toggleIcon.textContent = '‚àí';
        } else {
            queueContent.classList.add('hidden');
            toggleIcon.textContent = '+';
        }
    }
    
    // Add digits to queue
    function addDigitsToQueue() {
        const input = document.getElementById('digitInput');
        const value = input.value.trim();
        
        if (!value) {
            log('‚ùå Please enter digits', 'ERROR');
            return;
        }
        
        // Parse digits (allow commas, spaces, or any delimiter)
        const digitStrings = value.split(/[,\s]+/);
        const newDigits = [];
        
        digitStrings.forEach(str => {
            const num = parseInt(str.trim());
            if (!isNaN(num) && num >= 0 && num <= 9) {
                newDigits.push(num);
            }
        });
        
        if (newDigits.length === 0) {
            log('‚ùå No valid digits (0-9) found', 'ERROR');
            return;
        }
        
        // Add to queue
        window.digitQueue.digits = [...window.digitQueue.digits, ...newDigits];
        window.digitQueue.active = true;
        
        // Update UI
        updateDigitQueueDisplay();
        
        // Highlight input
        input.classList.add('queue-input-highlight');
        setTimeout(() => input.classList.remove('queue-input-highlight'), 500);
        
        log(`‚úÖ Added ${newDigits.length} digits to queue: [${newDigits.join(', ')}]`, 'QUEUE');
        
        // Reset input
        input.value = '';
        
        // If this is the first digit added, set it as current
        if (window.digitQueue.position === 0 && window.digitQueue.digits.length > 0) {
            getNextDigitFromQueue();
        }
    }
    
    // Clear digit queue
    function clearDigitQueue() {
        if (window.digitQueue.digits.length === 0) return;
        
        const confirmClear = confirm('Clear all digits from queue?');
        if (!confirmClear) return;
        
        window.digitQueue.digits = [];
        window.digitQueue.position = 0;
        window.digitQueue.currentDigit = null;
        window.digitQueue.cyclesCompleted = 0;
        window.digitQueue.active = false;
        window.digitQueue.shuffledDigits = [];
        window.digitQueue.shufflePosition = 0;
        
        updateDigitQueueDisplay();
        updateQueueStatus();
        
        log('üîÑ Digit queue cleared', 'QUEUE');
    }
    
    // Set queue execution mode
    function setQueueMode(mode) {
        window.digitQueue.mode = mode;
        
        // Update UI buttons
        document.getElementById('queueModeSequential').classList.remove('queue-mode-active');
        document.getElementById('queueModeRandom').classList.remove('queue-mode-active');
        
        if (mode === 'sequential') {
            document.getElementById('queueModeSequential').classList.add('queue-mode-active');
            document.getElementById('queueModeDescription').textContent = 
                'Sequential: Execute digits in order from first to last';
        } else {
            document.getElementById('queueModeRandom').classList.add('queue-mode-active');
            document.getElementById('queueModeDescription').textContent = 
                'Random: Execute digits in random order (without repeats until all used)';
        }
        
        document.getElementById('queueModeDisplay').textContent = mode.toUpperCase();
        document.getElementById('metricQueueMode').textContent = mode.toUpperCase();
        
        log(`üîÑ Queue mode set to: ${mode}`, 'QUEUE');
    }
    
    // Get next digit from queue based on mode
    function getNextDigitFromQueue() {
        if (window.digitQueue.digits.length === 0) {
            window.digitQueue.currentDigit = null;
            return null;
        }
        
        let nextDigit;
        
        if (window.digitQueue.mode === 'sequential') {
            // Sequential mode: go in order
            nextDigit = window.digitQueue.digits[window.digitQueue.position];
            window.digitQueue.position = (window.digitQueue.position + 1) % window.digitQueue.digits.length;
            
            // Check if we completed a cycle
            if (window.digitQueue.position === 0) {
                window.digitQueue.cyclesCompleted++;
                log(`üîÑ Completed cycle ${window.digitQueue.cyclesCompleted}`, 'QUEUE');
                
                // Check if we've reached max cycles
                if (window.digitQueue.cyclesCompleted >= window.digitQueue.maxCycles) {
                    log(`‚èπÔ∏è Max cycles (${window.digitQueue.maxCycles}) reached`, 'QUEUE');
                    if (window.isBotRunning) {
                        stopBot();
                    }
                    return window.digitQueue.currentDigit;
                }
            }
        } else {
            // Random mode: shuffle and use each digit once per cycle
            if (!window.digitQueue.shuffledDigits || window.digitQueue.shuffledDigits.length === 0) {
                // Create a shuffled copy for this cycle
                window.digitQueue.shuffledDigits = [...window.digitQueue.digits];
                shuffleArray(window.digitQueue.shuffledDigits);
                window.digitQueue.shufflePosition = 0;
            }
            
            nextDigit = window.digitQueue.shuffledDigits[window.digitQueue.shufflePosition];
            window.digitQueue.shufflePosition++;
            
            // Check if we completed a cycle
            if (window.digitQueue.shufflePosition >= window.digitQueue.shuffledDigits.length) {
                window.digitQueue.shuffledDigits = [];
                window.digitQueue.cyclesCompleted++;
                log(`üîÑ Completed cycle ${window.digitQueue.cyclesCompleted} (random)`, 'QUEUE');
                
                // Check max cycles
                if (window.digitQueue.cyclesCompleted >= window.digitQueue.maxCycles) {
                    log(`‚èπÔ∏è Max cycles (${window.digitQueue.maxCycles}) reached`, 'QUEUE');
                    if (window.isBotRunning) {
                        stopBot();
                    }
                    return window.digitQueue.currentDigit;
                }
            }
        }
        
        window.digitQueue.currentDigit = nextDigit;
        
        // Update main predicted digit input
        document.getElementById('predictedDigit').value = nextDigit;
        
        // Update session digit in smart mode
        if (sessionState.mode === 'smart' && sessionState.sessionStarted) {
            sessionState.sessionDigit = nextDigit;
        }
        
        updateQueueStatus();
        updateDigitQueueDisplay();
        
        log(`üî¢ Queue digit: ${nextDigit} (Position: ${getQueuePositionDisplay()})`, 'QUEUE');
        
        return nextDigit;
    }
    
    // Shuffle array (for random mode)
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    
    // Skip to next digit manually
    function skipToNextDigit() {
        if (window.digitQueue.digits.length === 0) {
            log('‚ùå No digits in queue', 'ERROR');
            return;
        }
        
        const oldDigit = window.digitQueue.currentDigit;
        const newDigit = getNextDigitFromQueue();
        
        log(`‚è≠Ô∏è Skipped from digit ${oldDigit} to ${newDigit}`, 'QUEUE');
        updateTradeStatus('QUEUE', `Digit changed: ${oldDigit} ‚Üí ${newDigit}`, 'Continuing with new digit', 'normal');
    }
    
    // Reset queue position
    function resetQueuePosition() {
        window.digitQueue.position = 0;
        window.digitQueue.cyclesCompleted = 0;
        window.digitQueue.shuffledDigits = [];
        window.digitQueue.shufflePosition = 0;
        
        // Get first digit
        getNextDigitFromQueue();
        
        log('üîÑ Queue position reset to start', 'QUEUE');
    }
    
    // Update queue display
    function updateDigitQueueDisplay() {
        const displayElem = document.getElementById('digitQueueDisplay');
        const countElem = document.getElementById('queueCount');
        
        countElem.textContent = window.digitQueue.digits.length;
        
        if (window.digitQueue.digits.length === 0) {
            displayElem.innerHTML = '<div class="text-xs text-gray-500 italic">No digits in queue</div>';
            return;
        }
        
        let html = '';
        const currentDigit = window.digitQueue.currentDigit;
        
        window.digitQueue.digits.forEach((digit, index) => {
            let className = 'digit-queue-item';
            let bgColor = 'bg-gray-700';
            let textColor = 'text-white';
            
            // Determine position for sequential mode
            let isActive = false;
            let isNext = false;
            
            if (window.digitQueue.mode === 'sequential') {
                isActive = (window.digitQueue.position === 0 && index === window.digitQueue.digits.length - 1) ? 
                           (currentDigit === digit) : 
                           (index === (window.digitQueue.position - 1 + window.digitQueue.digits.length) % window.digitQueue.digits.length);
                isNext = index === window.digitQueue.position;
            } else {
                isActive = currentDigit === digit;
                // For random mode, next is harder to determine, so we'll just show current
            }
            
            if (isActive) {
                className += ' digit-queue-active';
                bgColor = 'bg-green-600';
            } else if (isNext && window.digitQueue.mode === 'sequential') {
                className += ' digit-queue-next';
                bgColor = 'bg-yellow-600';
            }
            
            html += `<div class="${className} ${bgColor} ${textColor}" title="Digit ${digit}">${digit}</div>`;
        });
        
        displayElem.innerHTML = html;
    }
    
    // Update queue status display
    function updateQueueStatus() {
        const currentDigitElem = document.getElementById('currentQueueDigit');
        const positionElem = document.getElementById('queuePosition');
        const modeElem = document.getElementById('queueModeDisplay');
        
        const queuePositionElem = document.getElementById('metricQueuePosition');
        const queueCycleElem = document.getElementById('metricQueueCycle');
        const currentQueueDigitElem = document.getElementById('metricCurrentQueueDigit');
        const nextQueueDigitElem = document.getElementById('metricNextQueueDigit');
        const queueModeElem = document.getElementById('metricQueueMode');
        
        if (window.digitQueue.digits.length > 0 && window.digitQueue.currentDigit !== null) {
            currentDigitElem.textContent = window.digitQueue.currentDigit;
            positionElem.textContent = getQueuePositionDisplay();
            modeElem.textContent = window.digitQueue.mode.toUpperCase();
            
            queuePositionElem.textContent = getQueuePositionDisplay();
            queueCycleElem.textContent = window.digitQueue.cyclesCompleted + 1;
            currentQueueDigitElem.textContent = window.digitQueue.currentDigit;
            
            // Show next digit for sequential mode
            if (window.digitQueue.mode === 'sequential' && window.digitQueue.digits.length > 1) {
                const nextIndex = window.digitQueue.position;
                nextQueueDigitElem.textContent = window.digitQueue.digits[nextIndex];
            } else {
                nextQueueDigitElem.textContent = '?';
            }
            
            queueModeElem.textContent = window.digitQueue.mode.toUpperCase();
        } else {
            currentDigitElem.textContent = '-';
            positionElem.textContent = '-/-';
            modeElem.textContent = '-';
            
            queuePositionElem.textContent = '-';
            queueCycleElem.textContent = '1';
            currentQueueDigitElem.textContent = '-';
            nextQueueDigitElem.textContent = '-';
            queueModeElem.textContent = '-';
        }
    }
    
    // Get queue position display string
    function getQueuePositionDisplay() {
        if (window.digitQueue.digits.length === 0) return '-/-';
        
        if (window.digitQueue.mode === 'sequential') {
            const displayPos = window.digitQueue.position === 0 ? 
                window.digitQueue.digits.length : 
                window.digitQueue.position;
            return `${displayPos}/${window.digitQueue.digits.length}`;
        } else {
            // For random mode, show cycle progress
            const currentPos = window.digitQueue.shufflePosition || 0;
            return `${currentPos}/${window.digitQueue.digits.length}`;
        }
    }
    
    // Load digit presets
    function loadDigitPreset(preset) {
        let digits = [];
        
        switch(preset) {
            case 'even':
                digits = [0, 2, 4, 6, 8];
                break;
            case 'odd':
                digits = [1, 3, 5, 7, 9];
                break;
            case 'low':
                digits = [0, 1, 2, 3, 4];
                break;
            case 'high':
                digits = [5, 6, 7, 8, 9];
                break;
            case 'random5':
                // Generate 5 random unique digits
                const allDigits = [0,1,2,3,4,5,6,7,8,9];
                shuffleArray(allDigits);
                digits = allDigits.slice(0, 5);
                break;
        }
        
        // Add to queue
        window.digitQueue.digits = [...window.digitQueue.digits, ...digits];
        window.digitQueue.active = true;
        
        updateDigitQueueDisplay();
        
        // Get first digit if queue was empty
        if (window.digitQueue.position === 0 && window.digitQueue.digits.length > 0) {
            getNextDigitFromQueue();
        }
        
        log(`‚úÖ Loaded ${preset} preset: [${digits.join(', ')}]`, 'QUEUE');
    }
    
    // Initialize queue settings from UI
    function initializeQueueSettings() {
        window.digitQueue.cycleOnWin = document.getElementById('queueCycleOnWin').checked;
        window.digitQueue.restartAtEnd = document.getElementById('queueRestartAtEnd').checked;
        window.digitQueue.maxCycles = parseInt(document.getElementById('queueMaxCycles').value) || 1;
    }

    // ============================================================================
    // REMOVAL: Adaptive Strategy Override
    // ============================================================================

    /**
     * REMOVAL: Adaptive Strategy
     * This function is now empty to prevent re-analysis during a loss streak.
     * The Queue system now handles strategy adjustments.
     */
    function checkAdaptiveStrategy() {
        // Disabled: The bot now follows the Top 5 Queue on loss 
        // instead of pausing for re-analysis.
        return false; 
    }

    // Override the original checkAndReanalyze function
    window.checkAndReanalyze = function() {
        return false; // Disable adaptive reanalysis
    };

    // ============================================================================
    // MARTINGALE CALCULATOR FUNCTIONS
    // ============================================================================
    
    let calculatorExpanded = true;
    
    function toggleCalculator() {
        calculatorExpanded = !calculatorExpanded;
        const calculatorContent = document.getElementById('calculatorContent');
        const toggleIcon = document.getElementById('calcToggleIcon');
        
        if (calculatorExpanded) {
            calculatorContent.classList.remove('hidden');
            toggleIcon.textContent = '‚àí';
        } else {
            calculatorContent.classList.add('hidden');
            toggleIcon.textContent = '+';
        }
    }
    
    function calculateMartingale() {
        try {
            const baseStake = parseFloat(document.getElementById('calc_base_stake').value) || 1.0;
            const multiplier = parseFloat(document.getElementById('calc_multiplier').value) || 1.15;
            const maxTrades = parseInt(document.getElementById('calc_max_trades').value) || 10;
            const bankrollLimit = parseFloat(document.getElementById('calc_bankroll_limit').value) || 50.0;
            
            if (baseStake <= 0 || multiplier <= 1.0 || maxTrades <= 0) {
                alert('Please enter valid values for calculation.');
                return;
            }
            
            let currentStake = baseStake;
            let totalRequired = 0;
            let progression = [];
            let finalStake = baseStake;
            
            // Calculate progression and totals
            for (let i = 1; i <= maxTrades; i++) {
                if (i === 1) {
                    currentStake = baseStake;
                } else {
                    currentStake *= multiplier;
                }
                
                // Round to 2 decimal places
                currentStake = Math.round(currentStake * 100) / 100;
                totalRequired += currentStake;
                finalStake = currentStake;
                
                progression.push({
                    trade: i,
                    stake: currentStake.toFixed(2),
                    cumulative: Math.round(totalRequired * 100) / 100
                });
            }
            
            // Round total required
            totalRequired = Math.round(totalRequired * 100) / 100;
            
            // Calculate profit on win (DIGITMATCH pays 9x)
            const profitOnWin = (finalStake * 9) - totalRequired;
            
            // Update main bot controls with calculated values
            document.getElementById('baseStake').value = baseStake.toFixed(2);
            document.getElementById('multiplier').value = multiplier.toFixed(2);
            document.getElementById('maxTrades').value = maxTrades;
            
            // Update calculator results
            document.getElementById('calc_total_required').textContent = `$${totalRequired.toFixed(2)}`;
            document.getElementById('calc_final_stake').textContent = `$${finalStake.toFixed(2)}`;
            document.getElementById('calc_profit_on_win').textContent = `$${profitOnWin.toFixed(2)}`;
            
            // Update bankroll status
            const bankrollStatusElem = document.getElementById('calc_bankroll_status');
            bankrollStatusElem.classList.remove('calculator-safe', 'calculator-warning', 'calculator-highlight');
            
            if (totalRequired <= bankrollLimit) {
                bankrollStatusElem.textContent = '‚úÖ Within Limit';
                bankrollStatusElem.classList.add('calculator-safe');
            } else if (totalRequired <= bankrollLimit * 1.5) {
                bankrollStatusElem.textContent = '‚ö†Ô∏è Close to Limit';
                bankrollStatusElem.classList.add('calculator-warning');
            } else {
                bankrollStatusElem.textContent = '‚ùå Over Limit';
                bankrollStatusElem.classList.add('calculator-warning');
            }
            
            // Update progression display
            const progressionElem = document.getElementById('calc_progression');
            let progressionHTML = '<div class="grid grid-cols-4 gap-1 text-xs mb-1 font-semibold text-gray-300">';
            progressionHTML += '<div>Trade #</div><div>Stake</div><div>Cumulative</div><div>Status</div>';
            progressionHTML += '</div>';
            
            progression.forEach(item => {
                const status = item.cumulative <= bankrollLimit ? '‚úÖ' : '‚ùå';
                progressionHTML += `
                    <div class="grid grid-cols-4 gap-1 text-xs py-1 ${item.trade % 2 === 0 ? 'bg-gray-800/50' : ''}">
                        <div class="text-gray-300">${item.trade}</div>
                        <div class="text-green-400">$${item.stake}</div>
                        <div class="text-blue-400">$${item.cumulative.toFixed(2)}</div>
                        <div class="${status === '‚úÖ' ? 'text-green-400' : 'text-red-400'}">${status}</div>
                    </div>
                `;
            });
            
            progressionElem.innerHTML = progressionHTML;
            
            // Add pulse animation
            document.getElementById('calc_total_required').classList.add('calculator-pulse');
            setTimeout(() => {
                document.getElementById('calc_total_required').classList.remove('calculator-pulse');
            }, 500);
            
            log(`üßÆ Calculator: Total required: $${totalRequired.toFixed(2)} for ${maxTrades} trades`, 'CALCULATOR');
            
        } catch (error) {
            console.error('Calculator error:', error);
            alert('Error in calculation. Please check your inputs.');
        }
    }
    
    function syncCalculatorWithMain() {
        const baseStake = parseFloat(document.getElementById('baseStake').value) || 1.0;
        const multiplier = parseFloat(document.getElementById('multiplier').value) || 1.15;
        const maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
        
        document.getElementById('calc_base_stake').value = baseStake.toFixed(2);
        document.getElementById('calc_multiplier').value = multiplier.toFixed(2);
        document.getElementById('calc_max_trades').value = maxTrades;
        
        // Auto-calculate when main controls change
        calculateMartingale();
    }

    // ============================================================================
    // CORE BOT FUNCTIONS CONTINUED
    // ============================================================================
    
    // Check for authentication token
    function checkAuthToken() {
        const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
        if (!token) {
            log('‚ö†Ô∏è No API token found. Please authenticate first.', 'WARNING');
            document.getElementById('prediction_text').textContent = 'Authentication required';
            return false;
        }
        return true;
    }
    
    // Initialize account toggle
    function initializeToggleState() {
        const token = localStorage.getItem('active_token');
        const allAccounts = JSON.parse(localStorage.getItem('deriv_accounts')) || [];
        
        if (token && allAccounts.length > 0) {
            const currentAccount = allAccounts.find(acc => acc.token === token);
            if (currentAccount) {
                const isReal = !currentAccount.account.startsWith('VR');
                document.getElementById('accTypeToggle').checked = isReal;
                log(`Account: ${isReal ? 'REAL' : 'DEMO'} (${currentAccount.account})`, 'SYSTEM');
            }
        }
    }
    
    // Switch account
    function switchAccount() {
        const isRealRequested = document.getElementById('accTypeToggle').checked;
        const allAccounts = JSON.parse(localStorage.getItem('deriv_accounts')) || [];
        
        const targetAccount = allAccounts.find(acc => 
            isRealRequested ? !acc.account.startsWith('VR') : acc.account.startsWith('VR')
        );
    
        if (targetAccount) {
            localStorage.setItem('active_token', targetAccount.token);
            log(`Switched to ${isRealRequested ? 'REAL' : 'DEMO'} account`, 'SYSTEM');
            
            if (window.isBotRunning) {
                stopBot();
                setTimeout(() => startBot(), 1000);
            }
        } else {
            alert(`No ${isRealRequested ? 'Real' : 'Demo'} account found`);
            document.getElementById('accTypeToggle').checked = !isRealRequested;
        }
    }
    
    // TRADE STATUS UI FUNCTIONS
    function updateTradeStatus(status, result, action, type = 'normal') {
        tradeResultContainer.classList.remove('win-glow');
        metricPreviousResult.textContent = result;
        metricNextAction.textContent = action;
        
        switch(type) {
            case 'win':
                metricTradeResult.textContent = 'WIN üéØ';
                metricTradeResult.className = 'text-xs font-bold status-win';
                metricPreviousResult.className = 'text-sm font-bold status-win';
                metricNextAction.className = 'text-sm font-bold text-green-400';
                tradeResultContainer.classList.add('win-glow');
                log(`üéØ Trade Status: ${result}`, 'WIN');
                break;
            case 'loss':
                metricTradeResult.textContent = 'LOSS ‚ùå';
                metricTradeResult.className = 'text-xs font-bold status-loss';
                metricPreviousResult.className = 'text-sm font-bold status-loss';
                metricNextAction.className = 'text-sm font-bold text-red-400';
                log(`‚ùå Trade Status: ${result}`, 'LOSS');
                break;
            case 'trade':
                metricTradeResult.textContent = 'TRADING ‚ö°';
                metricTradeResult.className = 'text-xs font-bold status-trade';
                metricPreviousResult.className = 'text-sm font-bold status-trade';
                metricNextAction.className = 'text-sm font-bold text-yellow-400';
                log(`‚ö° Trade Status: ${result}`, 'TRADE');
                break;
            default:
                metricTradeResult.textContent = status || 'READY';
                metricTradeResult.className = 'text-xs font-bold text-gray-400';
                metricPreviousResult.className = 'text-sm font-bold text-gray-300';
                metricNextAction.className = 'text-sm font-bold text-yellow-400';
                break;
        }
    }
    
    function resetTradeStatus() {
        updateTradeStatus('READY', 'Waiting for connection...', 'Start bot to begin', 'normal');
    }
    
    // SESSION MANAGEMENT
    function startNewAnalysis() {
        if (!window.isBotRunning) {
            log('‚ùå Bot is not running', 'ERROR');
            return;
        }
        
        if (sessionState.sessionStarted && window.tradeCount > 0) {
            const confirmReset = confirm('‚ö†Ô∏è Starting new analysis will reset current session. Continue?');
            if (!confirmReset) return;
        }
        
        analysisDigits = [];
        analysisComplete = false;
        suggestedDigit = null;
        sessionState.sessionDigit = null;
        sessionState.manualOverride = false;
        
        document.getElementById('prediction_text').textContent = 'Running new analysis...';
        document.getElementById('prediction_box').classList.remove('analysis-complete');
        
        updateAnalysisUI('?');
        log('üîÑ Starting new analysis...', 'ANALYSIS');
        sessionDisplay.classList.add('hidden');
    }
    
    function updateSessionDisplay() {
        if (sessionState.sessionStarted && sessionState.sessionDigit !== null) {
            document.getElementById('session_digit').textContent = sessionState.sessionDigit;
            document.getElementById('session_mode').textContent = sessionState.mode.toUpperCase();
            document.getElementById('session_trades').textContent = `${window.tradeCount}/${window.maxTrades}`;
            sessionDisplay.classList.remove('hidden');
        } else {
            sessionDisplay.classList.add('hidden');
        }
    }
    
    function lockSessionDigit(digit) {
        if (sessionState.sessionStarted && sessionState.sessionDigit !== null) {
            log(`üîí Digit ${digit} is already locked for this session`, 'SESSION');
            return sessionState.sessionDigit;
        }
        
        sessionState.sessionDigit = digit;
        sessionState.sessionStarted = true;
        sessionState.manualOverride = false;
        document.getElementById('predictedDigit').value = digit;
        updateSessionDisplay();
        log(`üîí Digit ${digit} locked for current session`, 'SESSION');
        return digit;
    }
    
    // ANALYSIS ENGINE
    function updateConnectionStatus() {
        const isConnected = window.ws && window.ws.readyState === WebSocket.OPEN;
        const isConnecting = window.isConnecting || false;
        
        if (isConnected) {
            document.getElementById('status-badge').textContent = 'üü¢ CONNECTED';
            document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-connected text-white shadow-md';
            document.getElementById('market_status').textContent = 'Live';
            document.getElementById('market_status').className = 'ml-2 font-bold text-green-400';
            updateTradeStatus('CONNECTED', 'Market live - Ready to trade', 'Set parameters and start trading', 'normal');
        } else if (isConnecting) {
            document.getElementById('status-badge').textContent = 'üü° CONNECTING';
            document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-connecting text-white shadow-md';
            document.getElementById('market_status').textContent = 'Connecting...';
            document.getElementById('market_status').className = 'ml-2 font-bold text-yellow-400';
            updateTradeStatus('CONNECTING', 'Connecting to market...', 'Please wait', 'normal');
        } else {
            document.getElementById('status-badge').textContent = 'üî¥ DISCONNECTED';
            document.getElementById('status-badge').className = 'ml-3 inline-flex items-center px-3 py-1 text-sm font-medium rounded-full connection-badge-disconnected text-white shadow-md';
            document.getElementById('market_status').textContent = 'Offline';
            document.getElementById('market_status').className = 'ml-2 font-bold text-red-400';
            updateTradeStatus('DISCONNECTED', 'Market offline', 'Start bot to connect', 'normal');
        }
        
        document.getElementById('current_symbol').textContent = 
            document.getElementById('symbol').options[document.getElementById('symbol').selectedIndex].text;
        document.getElementById('ticks_received').textContent = totalTicksReceived;
        
        const now = Date.now();
        const recentTicks = tickTimestamps.filter(ts => now - ts < 5000);
        const tickRate = recentTicks.length / 5;
        document.getElementById('current_tick_rate').textContent = tickRate.toFixed(1) + '/s';
    }
    
    function processTickForAnalysis(tick) {
        try {
            const price = parseFloat(tick.quote);
            const symbol = document.getElementById('symbol').value;
            let decimalPlaces = 3;
            if (symbol === 'R_100') decimalPlaces = 2;
            const formattedPrice = price.toFixed(decimalPlaces);
            const digit = parseInt(formattedPrice.charAt(formattedPrice.length - 1), 10);
            
            if (isNaN(digit) || digit < 0 || digit > 9) return;
            
            totalTicksReceived++;
            lastTickTime = Date.now();
            tickTimestamps.push(lastTickTime);
            
            const tenSecondsAgo = Date.now() - 10000;
            tickTimestamps = tickTimestamps.filter(ts => ts > tenSecondsAgo);
            
            analysisDigits.push(digit);
            if (analysisDigits.length > analysisWindowSize) {
                analysisDigits.shift();
            }
            
            updateAnalysisUI(digit);
            
            if (!sessionState.sessionStarted && analysisDigits.length >= analysisWindowSize) {
                performAnalysis();
            }
            
            if (totalTicksReceived <= 5) {
                log(`üìä Tick #${totalTicksReceived}: ${price.toFixed(3)} (Digit ${digit})`, 'TICK');
            }
            
        } catch (error) {
            console.error('Tick processing error:', error);
        }
    }
    
    function updateAnalysisUI(currentDigit) {
        updateConnectionStatus();
        document.getElementById('tick_counter').textContent = analysisDigits.length;
        const progressPercent = Math.min(100, (analysisDigits.length / analysisWindowSize) * 100);
        document.getElementById('tick_progress_bar').style.width = `${progressPercent}%`;
        
        const statusElem = document.getElementById('analysis_status');
        if (analysisDigits.length < analysisWindowSize) {
            statusElem.textContent = `Collecting: ${analysisDigits.length}/${analysisWindowSize}`;
            statusElem.className = 'text-xs text-cyan-400';
        } else {
            statusElem.textContent = '‚úÖ Analysis complete';
            statusElem.className = 'text-xs text-green-400';
        }
        
        document.getElementById('window_size').textContent = analysisWindowSize;
    }
    
    function updatePredictionBox() {
        const box = document.getElementById('prediction_box');
        if (suggestedDigit !== null) {
            box.innerHTML = `
                <div class="text-cyan-300 font-bold mb-1">Prediction:</div>
                <div class="text-xl font-bold mb-2 text-center text-green-400">${suggestedDigit}</div>
                <div class="text-xs text-gray-300">Based on ${analysisWindowSize} market ticks</div>
            `;
            box.classList.add('analysis-complete');
        } else if (sessionState.sessionDigit !== null) {
            box.innerHTML = `
                <div class="text-cyan-300 font-bold mb-1">Session Digit:</div>
                <div class="text-xl font-bold mb-2 text-center session-digit-locked px-3 py-1 rounded-lg">${sessionState.sessionDigit}</div>
                <div class="text-xs text-gray-300">Locked for current session</div>
            `;
            box.classList.add('analysis-complete');
        }
    }
    
    document.getElementById('apply_tick_window').addEventListener('click', function() {
        const newSize = parseInt(document.getElementById('tick_window_input').value);
        if (newSize >= 3 && newSize <= 100) {
            analysisWindowSize = newSize;
            
            if (!sessionState.sessionStarted) {
                analysisDigits = [];
                analysisComplete = false;
                suggestedDigit = null;
                log(`üìä Analysis window: ${newSize} ticks`, 'ANALYSIS');
                updateAnalysisUI('?');
                document.getElementById('prediction_text').textContent = 'Waiting for market data...';
            } else {
                log(`üìä Analysis window updated to ${newSize} (digit remains locked)`, 'ANALYSIS');
            }
        }
    });
    
    // MODE MANAGEMENT
    function switchMode(mode) {
        sessionState.mode = mode;
        
        document.getElementById('mode_instant').classList.remove('bg-green-600', 'bg-blue-600');
        document.getElementById('mode_smart').classList.remove('bg-green-600', 'bg-blue-600');
        
        if (mode === 'instant') {
            document.getElementById('mode_instant').classList.add('bg-green-600');
            document.getElementById('mode_smart').classList.add('bg-blue-600');
            document.getElementById('mode_description').textContent = '‚ö° INSTANT: Trade on each tick';
            log('üîÑ Switched to INSTANT mode', 'SYSTEM');
            window.nextTradeAllowed = true;
            
            if (window.isBotRunning && !sessionState.manualOverride) {
                const manualDigit = parseInt(document.getElementById('predictedDigit').value);
                if (!isNaN(manualDigit) && manualDigit >= 0 && manualDigit <= 9) {
                    sessionState.sessionDigit = manualDigit;
                    sessionState.sessionStarted = true;
                    sessionState.manualOverride = true;
                    updateSessionDisplay();
                    updatePredictionBox();
                    log(`üîí Digit ${manualDigit} set manually for instant mode`, 'SESSION');
                }
            }
        } else {
            document.getElementById('mode_smart').classList.add('bg-green-600');
            document.getElementById('mode_instant').classList.add('bg-blue-600');
            document.getElementById('mode_description').textContent = 'üß† SMART: Analyze first, then trade';
            log('üîÑ Switched to SMART mode', 'SYSTEM');
            
            if (sessionState.sessionDigit !== null) {
                log(`üîí Using locked digit ${sessionState.sessionDigit}`, 'SESSION');
                updateExecutionLogic();
            } else {
                updateExecutionLogic();
            }
        }
    }
    
    function updateExecutionLogic() {
        if (sessionState.mode === 'smart' && !analysisComplete && !sessionState.sessionDigit) {
            log('üß† Waiting for analysis...', 'ANALYSIS');
            window.nextTradeAllowed = false;
            updateTradeStatus('ANALYZING', 'Analyzing market data...', 'Waiting for analysis completion', 'normal');
        } else if (sessionState.mode === 'smart' && sessionState.sessionDigit !== null) {
            log(`üß† Ready! Using locked digit: ${sessionState.sessionDigit}`, 'SESSION');
            window.nextTradeAllowed = true;
            document.getElementById('predictedDigit').value = sessionState.sessionDigit;
            updateTradeStatus('READY', `Digit ${sessionState.sessionDigit} locked`, 'Ready to trade', 'normal');
        } else if (sessionState.mode === 'instant') {
            window.nextTradeAllowed = true;
            updateTradeStatus('READY', 'Instant mode active', 'Trading on each tick', 'normal');
        }
    }
    
    // DOM Ready
    document.addEventListener('DOMContentLoaded', () => {
        console.log('ü§ñ Bot initialized');
        initializeToggleState();
        
        // Initialize queue system
        setQueueMode('sequential');
        initializeQueueSettings();
        updateDigitQueueDisplay();
        updateQueueStatus();
        
        // Add event listeners for queue settings
        document.getElementById('queueCycleOnWin').addEventListener('change', function() {
            window.digitQueue.cycleOnWin = this.checked;
        });
        
        document.getElementById('queueRestartAtEnd').addEventListener('change', function() {
            window.digitQueue.restartAtEnd = this.checked;
        });
        
        document.getElementById('queueMaxCycles').addEventListener('change', function() {
            window.digitQueue.maxCycles = parseInt(this.value) || 1;
        });
        
        if (!checkAuthToken()) {
            document.getElementById('prediction_text').textContent = 'Please authenticate first';
        }
        
        updateAnalysisUI('?');
        setInterval(calculateRates, 1000);
        startQueueProcessor();
        setInterval(updateLossStreakDisplay, 500);
        
        calculateMartingale();
        
        // Disable adaptive recheck since we're using queue system
        document.getElementById('enableRecheck').checked = false;
        window.recheckEnabled = false;
        document.getElementById('recheck-badge').classList.add('hidden');
        
        document.getElementById('baseStake').addEventListener('change', syncCalculatorWithMain);
        document.getElementById('multiplier').addEventListener('change', syncCalculatorWithMain);
        document.getElementById('maxTrades').addEventListener('change', syncCalculatorWithMain);
        document.getElementById('calc_base_stake').addEventListener('change', () => {
            document.getElementById('baseStake').value = document.getElementById('calc_base_stake').value;
        });
        document.getElementById('calc_multiplier').addEventListener('change', () => {
            document.getElementById('multiplier').value = document.getElementById('calc_multiplier').value;
        });
        document.getElementById('calc_max_trades').addEventListener('change', () => {
            document.getElementById('maxTrades').value = document.getElementById('calc_max_trades').value;
        });
        
        log('ü§ñ Bot ready with Digit Queue System', 'SYSTEM');
        switchMode('instant');
        updatePnL();
        resetTradeStatus();
        
        document.getElementById('predictedDigit').addEventListener('change', function() {
            const newDigit = parseInt(this.value);
            if (!isNaN(newDigit) && newDigit >= 0 && newDigit <= 9) {
                // If queue is active, add to queue instead of replacing
                if (window.digitQueue.active && window.digitQueue.digits.length > 0) {
                    log(`‚ö†Ô∏è Queue is active. Use queue panel to modify digits.`, 'QUEUE');
                    this.value = window.digitQueue.currentDigit || 5;
                    return;
                }
                
                if (sessionState.sessionStarted) {
                    const confirmChange = confirm('‚ö†Ô∏è Changing digit will reset current session. Continue?');
                    if (!confirmChange) {
                        this.value = sessionState.sessionDigit || 5;
                        return;
                    }
                }
                
                sessionState.sessionDigit = newDigit;
                sessionState.sessionStarted = true;
                sessionState.manualOverride = true;
                updateSessionDisplay();
                updatePredictionBox();
                log(`üî¢ Digit manually set to ${newDigit}`, 'SESSION');
                updateTradeStatus('MANUAL', `Digit manually set to ${newDigit}`, 'Ready to trade', 'normal');
            }
        });
    });
    
    // WEBSOCKET CONNECTION
    function connectWebSocket() {
        if (window.ws) {
            try {
                window.ws.close();
            } catch (e) {}
        }
        
        window.isConnecting = true;
        updateConnectionStatus();
        
        const wsUrl = 'wss://ws.binaryws.com/websockets/v3?app_id=118332';
        log('üîó Connecting to Deriv API...', 'SYSTEM');
        
        window.ws = new WebSocket(wsUrl);
        
        window.ws.onopen = () => {
            window.isConnecting = false;
            log('‚úÖ WebSocket connected', 'SYSTEM');
            updateConnectionStatus();
            
            const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
            if (!token) {
                log('‚ùå No API token found in storage', 'ERROR');
                stopBot();
                return;
            }
            
            sendRequest({ 
                authorize: token, 
                req_id: getNextReqId() 
            });
        };
        
        window.ws.onmessage = (msg) => {
            try {
                const data = JSON.parse(msg.data);
                handleAPIResponse(data);
            } catch (e) {
                console.error('WebSocket message error:', e);
            }
        };
        
        window.ws.onclose = () => {
            window.isConnecting = false;
            updateConnectionStatus();
            log('üîå WebSocket disconnected', 'SYSTEM');
            
            if (window.isBotRunning) {
                log('üîÑ Attempting to reconnect...', 'SYSTEM');
                setTimeout(() => {
                    if (window.isBotRunning) {
                        connectWebSocket();
                    }
                }, 2000);
            }
        };
        
        window.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            log('‚ùå WebSocket connection error', 'ERROR');
        };
    }
    
    // TICK HANDLER
    function handleTick(tick) {
        if (!window.isBotRunning) return;
        
        processTickForAnalysis(tick);
        
        const price = parseFloat(tick.quote);
        const symbol = document.getElementById('symbol').value;
        let decimalPlaces = 3;
        if (symbol === 'R_100') decimalPlaces = 2;
        const formattedPrice = price.toFixed(decimalPlaces);
        const digit = formattedPrice.charAt(formattedPrice.length - 1);
        
        const tickData = { 
            digit: digit, 
            price: price, 
            time: Date.now() 
        };
        
        window.lastTick = tickData;
        
        document.getElementById('metricLiveTick').textContent = price.toFixed(3);
        document.getElementById('metricLastDigit').textContent = `Digit: ${digit}`;
        document.getElementById('metricLiveTick').classList.add('tick-flash');
        setTimeout(() => document.getElementById('metricLiveTick').classList.remove('tick-flash'), 50);
        
        window.stats.totalTicks++;
        window.botTickTimestamps.push(Date.now());
        
        addTickToQueue(tickData);
        playAudioFeedback('TICK');
    }
    
    // Add tick to queue and analysisDigits
    function addTickToQueue(tick) {
        window.tickQueue.push(tick);
        if (window.tickQueue.length > window.maxQueueSize) {
            window.tickQueue.shift();
        }
        
        // Also add to analysisDigits for reanalysis
        const digit = parseInt(tick.digit);
        if (!isNaN(digit) && digit >= 0 && digit <= 9) {
            analysisDigits.push(digit);
            if (analysisDigits.length > 100) {
                analysisDigits.shift();
            }
        }
        
        return true;
    }
    
    function processTickImmediately(tick) {
        if (window.stopAfterWin) return;
        
        if (sessionState.mode === 'smart' && !analysisComplete && !sessionState.sessionDigit) {
            return;
        }
        
        if (checkForImmediateWin(tick)) {
            return;
        }
        
        if (window.tradeCount >= window.maxTrades) {
            log(`üõë Max trades reached (${window.maxTrades})`, 'CRITICAL');
            updateTradeStatus('MAX TRADES', `Maximum trades reached (${window.maxTrades})`, 'Bot stopped', 'loss');
            stopBot();
            return;
        }
        
        window.executionLock = true;
        window.nextTradeAllowed = false;
        
        try {
            window.stats.tradesExecuted++;
            window.tradeCount++;
            document.getElementById('metricTradeCount').textContent = window.tradeCount;
            
            updateSessionDisplay();
            log(`‚ö° Trade #${window.tradeCount}: ${tick.price.toFixed(3)} (Digit ${tick.digit})`, 'TRADE');
            
            updateTradeStatus(
                'TRADING',
                `Trade #${window.tradeCount}: $${window.currentStake.toFixed(2)} on digit ${getPredictedDigit()}`,
                'Executing trade...',
                'trade'
            );
            
            playAudioFeedback('EXECUTION');
            executeTrade(tick);
            
        } catch (error) {
            log(`‚ùå Error: ${error}`, 'ERROR');
            window.executionLock = false;
            window.nextTradeAllowed = true;
            updateTradeStatus('ERROR', `Trade failed: ${error}`, 'Retrying...', 'loss');
        }
    }
    
    function executeTrade(tick) {
        const contractType = document.getElementById('contractType').value;
        const symbol = document.getElementById('symbol').value;
        const predictedDigit = getPredictedDigit();
        
        let stake = window.currentStake;
        trackTradeInvestment(stake);
        
        const proposalRequest = {
            proposal: 1,
            amount: stake.toFixed(2),
            basis: "stake",
            contract_type: contractType,
            currency: "USD",
            duration: 1,
            duration_unit: "t",
            symbol: symbol,
            barrier: predictedDigit.toString(),
            req_id: getNextReqId()
        };
        
        window.pendingProposals.set(proposalRequest.req_id, {
            tick: tick,
            stake: stake,
            contractType: contractType,
            predictedDigit: predictedDigit,
            startTime: Date.now(),
            tradeNumber: window.tradeCount,
            martingaleStep: window.martingaleStep
        });
        
        sendRequest(proposalRequest);
    }
    
    // Get predicted digit from queue or single input
    function getPredictedDigit() {
        // If queue is active and has digits, use queue
        if (window.digitQueue.active && window.digitQueue.digits.length > 0 && window.digitQueue.currentDigit !== null) {
            return window.digitQueue.currentDigit;
        }
        
        // Otherwise use single digit input
        return parseInt(document.getElementById('predictedDigit').value);
    }
    
    // Update checkForImmediateWin to use queue
    function checkForImmediateWin(tick) {
        if (!window.isBotRunning || window.stopAfterWin) return false;
        
        const predictedDigit = getPredictedDigit();
        const tickDigit = parseInt(tick.digit);
        
        if (tickDigit === predictedDigit) {
            log(`üéØ IMMEDIATE WIN! Digit ${tickDigit} matches ${predictedDigit}`, 'WIN');
            
            // Handle win - call contract result handler
            handleContractResult(true);
            
            window.lastTradeResult = 'win';
            window.stopAfterWin = true;
            window.stats.wins++;
            window.tradeCount++;
            
            playAudioFeedback('WIN');
            
            const payout = window.currentStake * 9;
            trackTradePayout(payout);
            log(`üí∞ Payout: $${payout.toFixed(2)}`, 'PNL');
            
            // Start extended PnL updates for 3+ seconds
            startExtendedPnlUpdate(payout);
            
            updateTradeStatus(
                'IMMEDIATE WIN üéØ',
                `Digit ${tickDigit} matched! Payout: $${payout.toFixed(2)}`,
                'PnL updating for 3 seconds...',
                'win'
            );
            
            return true;
        }
        
        return false;
    }
    
    // PnL UPDATE FUNCTIONS - ENHANCED FOR 3+ SECOND UPDATES
    function startExtendedPnlUpdate(payout) {
        window.pnlUpdateStartTime = Date.now();
        
        // Clear any existing interval
        if (window.pnlUpdateInterval) {
            clearInterval(window.pnlUpdateInterval);
        }
        
        // Start with immediate update
        updatePnL();
        
        // Start continuous updates for 3+ seconds
        window.pnlUpdateInterval = setInterval(() => {
            const elapsed = Date.now() - window.pnlUpdateStartTime;
            
            if (elapsed >= window.pnlUpdateDuration) {
                // Stop after 3 seconds
                clearInterval(window.pnlUpdateInterval);
                window.pnlUpdateInterval = null;
                log('üí∞ PnL update sequence completed (3 seconds)', 'PNL');
                
                // Final update
                updatePnL();
                
                // Stop bot after PnL updates are complete
                setTimeout(() => {
                    if (window.isBotRunning) {
                        stopBot();
                    }
                }, 100);
            } else {
                // Continue updating PnL with visual feedback
                updatePnL();
                
                // Add visual pulse every 500ms
                if (elapsed % 500 < 50) {
                    metricTotalProfit.classList.add('pnl-update-animation');
                    setTimeout(() => {
                        metricTotalProfit.classList.remove('pnl-update-animation');
                    }, 500);
                }
                
                // Log progress every second
                if (elapsed % 1000 < 50) {
                    const secondsLeft = Math.ceil((window.pnlUpdateDuration - elapsed) / 1000);
                    log(`üí∞ PnL updating... ${secondsLeft}s`, 'PNL');
                }
            }
        }, 100); // Update every 100ms for smooth animation
    }
    
    function updatePnL() {
        const pnlElem = document.getElementById('metricTotalProfit');
        
        if (window.startingBalance > 0 && window.currentBalance > 0) {
            window.netProfit = window.currentBalance - window.startingBalance;
            const formattedProfit = window.netProfit.toFixed(2);
            const isPositive = window.netProfit > 0;
            const isNegative = window.netProfit < 0;
            
            pnlElem.textContent = `${isPositive ? '+' : ''}$${formattedProfit}`;
            pnlElem.classList.remove('profit-positive', 'profit-negative', 'profit-neutral');
            
            if (isPositive) pnlElem.classList.add('profit-positive');
            else if (isNegative) pnlElem.classList.add('profit-negative');
            else pnlElem.classList.add('profit-neutral');
            
            return window.netProfit;
        }
        
        if (window.pnlTracker.totalPayout > 0 || window.pnlTracker.totalInvestment > 0) {
            window.netProfit = window.pnlTracker.totalPayout - window.pnlTracker.totalInvestment;
            const formattedProfit = window.netProfit.toFixed(2);
            const isPositive = window.netProfit > 0;
            const isNegative = window.netProfit < 0;
            
            pnlElem.textContent = `${isPositive ? '+' : ''}$${formattedProfit}`;
            pnlElem.classList.remove('profit-positive', 'profit-negative', 'profit-neutral');
            
            if (isPositive) pnlElem.classList.add('profit-positive');
            else if (isNegative) pnlElem.classList.add('profit-negative');
            else pnlElem.classList.add('profit-neutral');
            
            return window.netProfit;
        }
        
        pnlElem.textContent = '$0.00';
        pnlElem.classList.remove('profit-positive', 'profit-negative');
        pnlElem.classList.add('profit-neutral');
        return 0;
    }
    
    function trackTradeInvestment(amount) {
        window.pnlTracker.totalInvestment += parseFloat(amount);
        window.pnlTracker.trades.push({
            type: 'investment',
            amount: parseFloat(amount),
            timestamp: Date.now()
        });
        updatePnL();
        log(`üí∞ Investment tracked: $${amount.toFixed(2)}`, 'PNL');
    }
    
    function trackTradePayout(amount) {
        window.pnlTracker.totalPayout += parseFloat(amount);
        window.pnlTracker.trades.push({
            type: 'payout',
            amount: parseFloat(amount),
            timestamp: Date.now()
        });
        updatePnL();
        log(`üí∞ Payout tracked: $${amount.toFixed(2)}`, 'PNL');
    }
    
    function resetPnL() {
        window.pnlTracker = { totalInvestment: 0.0, totalPayout: 0.0, netProfit: 0.0, trades: [] };
        window.startingBalance = 0.0;
        window.currentBalance = 0.0;
        window.netProfit = 0.0;
        
        if (window.pnlUpdateInterval) {
            clearInterval(window.pnlUpdateInterval);
            window.pnlUpdateInterval = null;
        }
        
        updatePnL();
        log('üí∞ PnL reset', 'PNL');
    }
    
    // Update metrics UI
    function updateMetricsUI() {
        const stakeElem = document.getElementById('metricCurrentStake');
        stakeElem.textContent = `$${window.currentStake.toFixed(2)}`;
        
        document.getElementById('metricTradeCount').textContent = window.tradeCount;
        updatePnL();
        updateLossStreakDisplay();
    }
    
    // Update stake function - MODIFIED for queue integration
    function updateStake(winOrLoss) {
        window.baseStake = parseFloat(document.getElementById('baseStake').value) || 1.0;
        window.multiplier = parseFloat(document.getElementById('multiplier').value) || 1.15;
        window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
        
        if (winOrLoss === 'win') {
            // Call contract result handler
            handleContractResult(true);
            
            const payout = window.currentStake * 9;
            trackTradePayout(payout);
            log(`üí∞ Payout: $${payout.toFixed(2)}`, 'PNL');
            
            // Start extended PnL updates for 3+ seconds
            startExtendedPnlUpdate(payout);
            
            updateTradeStatus(
                'WIN üéØ',
                `WON! Digit matched - Payout: $${payout.toFixed(2)}`,
                'PnL updating for 3 seconds...',
                'win'
            );
            
        } else if (winOrLoss === 'loss') {
            window.martingaleStep++;
            
            // Call contract result handler
            handleContractResult(false);
            
            if (window.martingaleStep >= window.maxTrades) {
                log(`üõë MAX TRADES REACHED (${window.maxTrades})`, 'CRITICAL');
                updateTradeStatus('MAX TRADES', `Maximum trades reached (${window.maxTrades})`, 'Bot stopped', 'loss');
                stopBot();
                return;
            }
            
            const newStake = window.currentStake * window.multiplier;
            window.currentStake = parseFloat(newStake.toFixed(2));
            log(`‚ùå LOSS. Next stake: $${window.currentStake.toFixed(2)} (Loss streak: ${window.consecutiveLosses}, Step: ${window.martingaleStep})`, 'LOSS');
            
            updateTradeStatus(
                'LOSS ‚ùå',
                `Lost - Streak: ${window.consecutiveLosses}, Next: $${window.currentStake.toFixed(2)}`,
                'Rotating to next digit in queue',
                'loss'
            );
            
            // Always update PnL
            updatePnL();
            
        } else {
            window.martingaleStep = 0;
            window.consecutiveLosses = 0;
            window.digitChangesThisSession = 0;
            window.currentStake = window.baseStake;
            log(`Starting. Base stake: $${window.currentStake.toFixed(2)}`, 'SYSTEM');
            updateTradeStatus('STARTING', `Base stake: $${window.currentStake.toFixed(2)}`, 'Waiting for trades', 'normal');
        }
        
        updateMetricsUI();
    }
    
    // START/STOP BOT - MODIFIED to ensure PnL updates
    function startBot() {
        if (window.isBotRunning) {
            stopBot();
            return;
        }
        
        window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
        
        const token = localStorage.getItem('active_token') || localStorage.getItem('derivToken');
        if (!token) {
            log('‚ùå No API token found. Please authenticate first.', 'CRITICAL');
            document.getElementById('prediction_text').textContent = 'Authentication required';
            updateTradeStatus('ERROR', 'No API token found', 'Please authenticate first', 'loss');
            return;
        }
        
        resetAllState();
        
        analysisDigits = [];
        analysisComplete = false;
        if (!sessionState.manualOverride) {
            suggestedDigit = null;
        }
        totalTicksReceived = 0;
        tickTimestamps = [];
        
        if (!sessionState.manualOverride) {
            sessionState.sessionDigit = null;
            sessionState.sessionStarted = false;
        }
        
        window.isBotRunning = true;
        updateButtonState();
        
        log('üöÄ Starting bot...', 'SYSTEM');
        log(`üìä Mode: ${sessionState.mode}`, 'SYSTEM');
        log(`üìä Max Trades: ${window.maxTrades}`, 'SYSTEM');
        log(`üîÑ Using Queue System (Top ${window.SMART_QUEUE_SIZE} digits)`, 'SYSTEM');
        log(`üîë Using token: ${token.substring(0, 10)}...`, 'SYSTEM');
        
        updateTradeStatus('STARTING', 'Initializing bot...', 'Connecting to market', 'normal');
        updateStake('initial');
        initTone();
        connectWebSocket();
        
        document.querySelectorAll('#symbol, #predictedDigit, #contractType, #baseStake, #multiplier, #maxTrades').forEach(control => {
            control.disabled = true;
            control.classList.add('opacity-50', 'cursor-not-allowed');
        });
        
        document.getElementById('new_analysis_btn').disabled = false;
    }
    
    function stopBot() {
        if (!window.isBotRunning) return;
        
        window.isBotRunning = false;
        window.nextTradeAllowed = false;
        window.stopAfterWin = false;
        updateButtonState();
        
        log('‚èπÔ∏è Bot stopped', 'SYSTEM');
        
        // Stop any ongoing PnL updates
        if (window.pnlUpdateInterval) {
            clearInterval(window.pnlUpdateInterval);
            window.pnlUpdateInterval = null;
        }
        
        if (window.ws) {
            window.ws.close();
            window.ws = null;
        }
        window.tickSubscriptionSent = false;
        window.pendingProposals.clear();
        window.executionLock = false;
        
        document.querySelectorAll('#symbol, #predictedDigit, #contractType, #baseStake, #multiplier, #maxTrades').forEach(control => {
            control.disabled = false;
            control.classList.remove('opacity-50', 'cursor-not-allowed');
        });
        
        document.getElementById('new_analysis_btn').disabled = true;
        
        updateConnectionStatus();
        
        // Ensure PnL is updated one more time before showing final status
        const finalPnL = updatePnL();
        log(`üí∞ Final PnL: ${finalPnL >= 0 ? '+' : ''}$${finalPnL.toFixed(2)}`, 'PNL');
        
        updateTradeStatus(
            'STOPPED',
            `Final PnL: ${finalPnL >= 0 ? '+' : ''}$${finalPnL.toFixed(2)}`,
            'Bot stopped - Ready for new session',
            finalPnL > 0 ? 'win' : 'normal'
        );
        
        sessionState.sessionStarted = false;
        sessionDisplay.classList.add('hidden');
    }
    
    function toggleBot() {
        if (window.isBotRunning) {
            stopBot();
        } else {
            startBot();
        }
    }
    
    // HELPER FUNCTIONS
    function calculateRates() {
        const now = Date.now();
        window.botTickTimestamps = window.botTickTimestamps.filter(ts => now - ts < 5000);
        const tickRate = window.botTickTimestamps.length / 5;
        document.getElementById('metricTickRate').textContent = `Ticks/sec: ${tickRate.toFixed(1)}`;
    }
    
    function toggleSound() {
        window.soundEnabled = !window.soundEnabled;
        localStorage.setItem('soundEnabled', window.soundEnabled);
        updateSoundButton();
        log(`üîä Sound ${window.soundEnabled ? 'ON' : 'OFF'}`, 'SYSTEM');
    }
    
    function updateSoundButton() {
        if (soundToggleButton) {
            soundToggleButton.textContent = window.soundEnabled ? 'üîä Sound ON' : 'üîá Sound OFF';
            soundToggleButton.className = window.soundEnabled ? 
                'px-4 py-2 bg-blue-600 text-white font-bold rounded-lg shadow hover:bg-blue-700 transition' :
                'px-4 py-2 bg-gray-600 text-white font-bold rounded-lg shadow hover:bg-gray-700 transition';
        }
    }
    
    async function initTone() {
        if (!window.soundEnabled) return;
        
        if (typeof Tone === 'undefined') {
            console.error("Tone.js not loaded");
            return;
        }
        
        try {
            await Tone.start();
            window.synth = new Tone.Synth().toDestination();
            window.ToneInitialized = true;
        } catch (e) {
            console.error("Audio init error:", e);
        }
    }
    
    function playAudioFeedback(type) {
        if (!window.soundEnabled || !window.ToneInitialized || !window.synth) return;
        
        try {
            if (type === 'WIN') {
                window.synth.triggerAttackRelease("C5", "8n");
                setTimeout(() => window.synth.triggerAttackRelease("E5", "8n"), 100);
                setTimeout(() => window.synth.triggerAttackRelease("G5", "8n"), 200);
            } else if (type === 'TICK') {
                window.synth.triggerAttackRelease("C4", "32n", Tone.now(), 0.3);
            } else if (type === 'EXECUTION') {
                window.synth.triggerAttackRelease("E5", "16n", Tone.now(), 0.5);
            }
        } catch (e) {
            console.error("Audio error:", e);
        }
    }
    
    function log(message, type = 'INFO') {
        const logArea = document.getElementById('log-area');
        const timestamp = new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit' 
        });
        
        let color = 'text-lime-400';
        if (type === 'ERROR') color = 'text-red-500 font-bold'; 
        if (type === 'WARNING') color = 'text-yellow-400';
        if (type === 'TRADE') color = 'text-green-300';
        if (type === 'WIN') color = 'text-green-400 font-bold';
        if (type === 'LOSS') color = 'text-red-400 font-bold';
        if (type === 'TICK') color = 'text-cyan-300';
        if (type === 'SYSTEM') color = 'text-white';
        if (type === 'ANALYSIS') color = 'text-cyan-300 font-bold';
        if (type === 'PNL') color = 'text-purple-300 font-bold';
        if (type === 'SESSION') color = 'text-blue-300 font-bold';
        if (type === 'CALCULATOR') color = 'text-purple-300 font-bold';
        if (type === 'STRATEGY') color = 'text-purple-300 font-bold';
        if (type === 'SETTINGS') color = 'text-blue-300 font-bold';
        if (type === 'QUEUE') color = 'text-blue-300 font-bold';
        
        logArea.innerHTML += `\n[${timestamp}] <span class="${color}">${message}</span>`;
        logArea.scrollTop = logArea.scrollHeight;
    }
    
    function updateButtonState() {
        if (!toggleButton) return;
        
        if (window.isBotRunning) {
            toggleButton.innerHTML = '<span class="flex items-center justify-center"><span class="mr-2">‚èπÔ∏è</span> STOP BOT</span>';
            toggleButton.classList.remove('bg-green-600', 'hover:bg-green-700', 'start-button-active');
            toggleButton.classList.add('stop-button-active', 'hover:bg-red-700');
        } else {
            toggleButton.innerHTML = '<span class="flex items-center justify-center"><span class="mr-2">üöÄ</span> START BOT</span>';
            toggleButton.classList.remove('stop-button-active', 'hover:bg-red-700');
            toggleButton.classList.add('bg-green-600', 'hover:bg-green-700', 'start-button-active');
        }
    }
    
    function startQueueProcessor() {
        setInterval(() => {
            if (!window.isBotRunning || window.stopAfterWin) return;
            
            while (window.tickQueue.length > 0 && !window.executionLock && window.nextTradeAllowed) {
                const tick = window.tickQueue.shift();
                processTickImmediately(tick);
            }
        }, 50);
    }
    
    function sendRequest(request) {
        if (window.ws && window.ws.readyState === WebSocket.OPEN) {
            const message = JSON.stringify(request);
            window.ws.send(message);
            return request.req_id;
        }
        return null;
    }
    
    function getNextReqId() {
        return ++window.req_id;
    }
    
    function handleAPIResponse(data) {
        if (data.error) {
            log(`API Error: ${data.error.message}`, 'ERROR');
            if (data.error.code === 'InvalidToken') {
                log('‚ùå Invalid API Token. Please check your authentication.', 'CRITICAL');
                stopBot();
            }
            return;
        }
    
        if (data.msg_type === 'authorize') {
            if (data.authorize) {
                log(`üîê Authorized as ${data.authorize.loginid}`, 'SYSTEM');
                subscribeToTicks(document.getElementById('symbol').value);
                subscribeToBalance();
            }
        } else if (data.msg_type === 'tick') {
            handleTick(data.tick);
        } else if (data.msg_type === 'proposal') {
            handleProposalResponse(data.proposal, data.req_id);
        } else if (data.msg_type === 'buy') {
            handleBuyResponse(data.buy);
        } else if (data.msg_type === 'balance') {
            handleBalanceUpdate(data.balance);
        }
    }
    
    function subscribeToBalance() {
        sendRequest({ balance: 1, subscribe: 1, req_id: getNextReqId() });
        log('üí∞ Subscribed to balance', 'SYSTEM');
    }
    
    function handleBalanceUpdate(balanceData) {
        const newBalance = parseFloat(balanceData.balance);
        
        if (window.startingBalance === 0) {
            window.startingBalance = newBalance;
            log(`üí∞ Starting Balance: $${window.startingBalance.toFixed(2)}`, 'PNL');
        }
        
        window.currentBalance = newBalance;
        const balanceElem = document.getElementById('metricAccountBalance');
        balanceElem.textContent = `$${window.currentBalance.toFixed(2)}`;
        balanceElem.className = 'text-lg font-bold balance-green';
        updatePnL();
    }
    
    function subscribeToTicks(symbol) {
        if (window.tickSubscriptionSent) return;
        
        sendRequest({ ticks: symbol, subscribe: 1, req_id: getNextReqId() });
        window.tickSubscriptionSent = true;
        log(`‚úÖ Subscribed to ${symbol} ticks`, 'SYSTEM');
    }
    
    function handleProposalResponse(proposal, req_id) {
        if (!proposal || !proposal.id) {
            log(`‚ùå Proposal failed`, 'ERROR');
            updateTradeStatus('ERROR', 'Proposal failed', 'Retrying...', 'loss');
            return;
        }
    
        const pending = window.pendingProposals.get(req_id);
        if (!pending) return;
    
        window.pendingProposals.delete(req_id);
        executeBuy(proposal.id, proposal.ask_price, pending);
    }
    
    function executeBuy(proposal_id, ask_price, pending) {
        const buyRequest = {
            buy: proposal_id,
            price: ask_price,
            req_id: getNextReqId()
        };
        
        log(`‚úÖ Buying: $${pending.stake.toFixed(2)} on digit ${pending.predictedDigit}`, 'TRADE');
        
        window.pendingProposals.set(buyRequest.req_id, {
            ...pending,
            proposal_id: proposal_id,
            buyStartTime: Date.now()
        });
        
        sendRequest(buyRequest);
    }
    
    function handleBuyResponse(buyData) {
        if (buyData.contract_id) {
            log(`‚úÖ Trade executed successfully`, 'TRADE');
            
            // Check if this was a win or loss
            const wasWin = buyData.longcode && buyData.longcode.includes("win");
            
            updateStake(wasWin ? 'win' : 'loss');
            onTradeComplete(true);
        } else {
            log(`‚ùå Trade failed`, 'ERROR');
            updateTradeStatus('ERROR', 'Trade execution failed', 'Retrying...', 'loss');
            onTradeComplete(false);
        }
    }
    
    function onTradeComplete(isSuccess = true) {
        window.executionLock = false;
        window.nextTradeAllowed = true;
        updateSessionDisplay();
        
        if (!isSuccess) {
            updateStake('loss');
        }
        
        if (window.stopAfterWin) {
            // Don't immediately stop, let updateStake handle it
            return;
        }
        
        if (window.tradeCount >= window.maxTrades) {
            log(`üõë Max trades reached (${window.maxTrades})`, 'CRITICAL');
            updateTradeStatus('MAX TRADES', `Maximum trades reached (${window.maxTrades})`, 'Bot stopped', 'loss');
            stopBot();
            return;
        }
    }
    
    // Reset all state to include queue
    function resetAllState() {
        window.maxTrades = parseInt(document.getElementById('maxTrades').value) || 10;
        window.consecutiveLosses = 0;
        window.digitChangesThisSession = 0;
        window.lastAnalysisTime = 0;
        window.lastRecheckTime = 0;
        
        // Reset queue position but keep digits
        window.digitQueue.position = 0;
        window.digitQueue.cyclesCompleted = 0;
        window.digitQueue.shuffledDigits = [];
        window.digitQueue.shufflePosition = 0;
        
        // Get first digit from queue if available
        if (window.digitQueue.digits.length > 0) {
            getNextDigitFromQueue();
        }
        
        updateStake('initial');
        resetPnL();
        resetTradeStatus();
        
        window.startingBalance = 0.0;
        window.currentBalance = 0.0;
        window.netProfit = 0.0;
        
        document.getElementById('metricTradeCount').textContent = '0';
        document.getElementById('metricAccountBalance').textContent = '$---';
        document.getElementById('metricLiveTick').textContent = '---';
        document.getElementById('metricLastDigit').textContent = 'Digit: ?';
        
        window.stats = { totalTicks: 0, tradesExecuted: 0, wins: 0, losses: 0 };
        window.tickQueue = [];
        window.lastTick = null;
        window.lastTradeResult = null;
        window.tradeCount = 0;
        window.martingaleStep = 0;
        window.pendingProposals.clear();
        window.botTickTimestamps = [];
        
        window.executionLock = false;
        window.waitingForTradeResult = false;
        window.nextTradeAllowed = true;
        window.stopAfterWin = false;
        
        const logArea = document.getElementById('log-area');
        logArea.innerHTML = '[00:00:00] ü§ñ Bot reset. Ready.';
        
        log('üîÑ Bot reset', 'SYSTEM');
        log('üîÑ Queue system reset', 'QUEUE');
        
        // Update queue display
        updateDigitQueueDisplay();
        updateQueueStatus();
    }
    
    // Update loss streak display
    function updateLossStreakDisplay() {
        const streakElem = document.getElementById('currentLossStreak');
        const changesElem = document.getElementById('digitChangesCount');
        
        if (streakElem) {
            streakElem.textContent = window.consecutiveLosses;
            if (window.consecutiveLosses >= window.recheckThreshold) {
                streakElem.classList.add('loss-streak-high');
            } else {
                streakElem.classList.remove('loss-streak-high');
            }
        }
        
        if (changesElem) {
            changesElem.textContent = window.digitChangesThisSession;
        }
    }
</script>
